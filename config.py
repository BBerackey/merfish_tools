"""Global configuration settings for the pipeline.

Settings
--------
merlin_folder
    The folder containing the output from MERlin.

image_folder
    The folder containing the raw image files.

segmentation_folder
    The folder containing the segmentation files.

output_folder
    The folder to save output to.

minimum_cell_volume

maximum_cell_volume

barcode_colors

mask_size
    The size (width and height) in pixels of the segmentation masks

scale
    The scale of the images compared to segmentation masks. For example, if the
    masks were generated by downsampling the images by a factor of 4, scale should
    be set to 4.

omit_fovs
    FOV ids to skip processing (currently not implemented)

reference_counts
    A filename with gene counts to correlate with. TODO: add more details about
    format this should be in

flip_barcodes
    If true, the positions of barcodes within a FOV should be flipped horizontally
    and vertically before assigning to the segmentation mask.

transpose_barcodes
    If true, the x and y positions of barcodes within a FOV should be swapped.

"""

import json
import os

config = {
    "omit_fovs": [],
    "reference_counts": [],
    "mask_size": 2048,
    "transpose_barcodes": False,
    "flip_barcodes": False,
    "scale": 1,
}
result_path = None


def get(key: str):
    return config[key]


def has(key: str) -> bool:
    return key in config


def update(settings: dict) -> None:
    for key, value in settings.items():
        config[key] = value


def load_from_file(config_file: str) -> None:
    global config
    with open(config_file) as conf:
        config.update(json.loads(conf.read()))


def load(args):
    global config
    if args.config_file:
        load_from_file(args.config_file)
    for key, value in vars(args).items():
        if value is None:
            continue
        config[key] = value
    config["scale"] = 2048 / config["mask_size"]


def path(filename):
    if not os.path.exists(get("output_folder")):
        os.mkdir(get("output_folder"))
    return os.path.join(get("output_folder"), filename)
